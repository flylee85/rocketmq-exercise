# 电商项目
rocketmq实战整理,生产者整合spring

## 本项目规划
本项目一共规划了五个服务，优惠券服务，订单服务，支付服务，用户服务，支付服务

## 防止超卖的策略：  
看goods项目的reduceGoodsNumber方法的sql

```
update trade_goods
set
  goods_number = goods_number-#{goodsNumber,jdbcType=INTEGER}
  where
     goods_id = #{goodsId,jdbcType=INTEGER}
  and goods_number>=#{goodsNumber,jdbcType=INTEGER}
```

判断当前的数量大于下单的数量

在下单失败的时候，加库存的时候首先校验有没有减库存的记录。

消息去重表中的消费次数，是当前消息的消费次数，如果次数达到某个阀值说明消费不管多少次都是失败的，改为人工处理。


##实现消费端消息重复消费的二种方式
一种使用业务去重，比如说在取消订单的时候，回退金额，先去金额日志表中查询该订单id有没有加款记录，有则说明这个消息已经消费过了，无需再去消费了，反之则可消费  
还有一种方式使用去重表，以消息id，业务id，消息tag，消息组名来确定一条唯一的记录，并且该记录有消费状态这个字段，如果该状态是已完成，则说明已经消费了这条记录，则不需要去操作这条记录了。


## 支付流程
先在本地生成一条支付记录，然后调用第三方支付接口，调用成功之后执行回调方法确定订单状态。  

## 生产端发可靠消息策略
因为发送消息和生产端的操作不在一个事务中，所以我们的设计思路就是在这点上：  
比如我们本demo的列子，在支付成功调用第三方支付接口回调的时候，要更新本地的支付状态为已支付，将订单服务中的订单记录的支付状态改为已支付。首先我们在更新支付表中的支付记录为已经支付的时候  
发送mq消息，发送消息之前先将消息记录记录在本地的库中，本地的trade_mq_producer_temp表，然后发送消息，mq消费端（本demo的order服务订阅了改主题之后消费成功 ack成功之后删除这个消息）  
如果这个阶段消息发送失败，此时因为本地库中的trade_mq_producer_temp中有消息记录，我们本地定时任务定期去跑任务重新发送这些消息。


## 最后说下创建订单流程
成功流程：
创建订单->创建不可见订单记录->校验一些入参->调用restful服务，进行使用优惠券，减库存，扣余额等操作->都成功了更改订单状态
失败流程：
创建订单->创建不可以见订单记录->校验一些入参->调用restful服务，由一个调用失败->发送mq消息，进行优惠券改回状态，加库存，加余额这些操作（这些服务都在订阅了相关的主题，根据消息中的内容进行相应的业务逻辑操作）


## 创建支付流程：
支付操作：
创建一个支付记录，标志为为未支付，然后调用第三方接口
如果支付成功的回调接口做了二件事，第一件是更改支付记录的状态为已支付，第二件事是发送可靠消息到order服务进行相关订单记录状态的修改。





